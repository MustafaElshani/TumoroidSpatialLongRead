# Start libraries
```{r setup, message=FALSE, warning=FALSE, echo=TRUE, eval=T, fig.height=4, fig.width=6}
# Load necessary libraries
library(Giotto)
library(dplyr)
library(ggplot2)
library(patchwork)
library(RColorBrewer)
library(terra)
library(exifr)

```

# Step 1: Load Full-Resolution Image and Extract Metadata
```{r step1_load_image}

# Load the full-resolution TIFF image using terra
data_dir_10x_30uM7738 <- "./30uM7738/analysis/wf-VISIUM/spaceranger_out_Run2_autoalign/outs"
fullres_image_path <- file.path(data_dir_10x_30uM7738, "spatial/tissue_fullres_image.tif")
fullres_image <- rast(fullres_image_path)

# Extract metadata from the TIFF file using exifr
tiff_file_path <- file.path(data_dir_10x_30uM7738, "spatial/tissue_fullres_image.tif")
metadata <- read_exif(tiff_file_path)

# Extract relevant fields: XResolution, YResolution, and ResolutionUnit
resolution_data <- metadata[, c("XResolution", "YResolution", "ResolutionUnit")]
microns_per_pixel <- 10000 / resolution_data$XResolution  # Convert pixels per cm to microns per pixel
print(paste("Microns per pixel:", microns_per_pixel))

# Check the original dimensions of the full-resolution image
fullres_dims <- dim(fullres_image)[1:2]
print(fullres_dims)
```

# Step 2: Downsample Image and Calculate Scaling Factor
```{r step2_downsample}
# Load the necessary library to read and write JSON files
library(jsonlite)

# Downsample the image using terra
downsample_factor <- 5 # Adjust as needed
fullres_image_downsampled <- aggregate(fullres_image, fact = downsample_factor)

# Flip the image vertically to correct orientation (terra uses bottom-left origin, PNG uses top-left)
fullres_image_downsampled <- terra::flip(fullres_image_downsampled, direction = "vertical")

# Save the downsampled image as a PNG
png_image_path <- file.path(data_dir_10x_30uM7738, "spatial/tissue_hires_image.png")
writeRaster(fullres_image_downsampled, filename = png_image_path, overwrite = TRUE)

# Calculate the new hires scaling factor
new_hires_scale <- dim(fullres_image_downsampled)[1] / fullres_dims[1]
print(paste("New hires scale factor:", new_hires_scale))

# Load the original scalefactors_json.json
scalefactor_json_path <- file.path(data_dir_10x_30uM7738, "spatial/scalefactors_json.json")
scalefactors <- fromJSON(scalefactor_json_path)

# Ensure all elements are numeric, and update the hires scale factor
scalefactors$tissue_hires_scalef <- as.numeric(new_hires_scale)

# Optionally, print the updated scalefactors to verify
print(scalefactors)

# Write the updated JSON back to the file with correct structure
write_json(scalefactors, scalefactor_json_path, pretty = TRUE, auto_unbox = TRUE)

# Verify the updated JSON file
print(paste("Updated scalefactors written to:", scalefactor_json_path))

```

# Step 3 Create the Giotto object
## createGiottoVisiumObject() will look for the standardized files organization from the visium technology in the data folder and will automatically load the expression and spatial information to create the Giotto object.

```{r step3_create_giotto}

# Set the Python path to the existing environment
python_path <- "/home/mustafa/miniforge3/envs/giotto_env/bin/python"

# Set up Giotto instructions with the manually specified Python path
results_folder <- "./results/Giotto_30uM7738_results/ONTgene"

# Create the results folder if it doesn't exist
if (!dir.exists(results_folder)) {
  dir.create(results_folder, recursive = TRUE)
}

# Create Giotto instructions with Python path
instrs <- createGiottoInstructions(
  save_plot = TRUE, 
  save_dir = results_folder, 
  show_plot = FALSE, 
  python_path = python_path
)

# Check instructions to confirm the setup
print(instrs)

```

# Change background to white 

```{r step3b_change_background}
library(magick)

# Load the image
image_path <- "./30uM7738/analysis/wf-VISIUM/spaceranger_out_Run2_autoalign/outs/spatial/tissue_hires_image.png"
image <- image_read(image_path)

# Convert image to CMYK and extract magenta and black channels
im_magenta <- image |>
  image_convert(colorspace = "cmyk") |>
  image_channel(channel = "Magenta")

im_black <- image |>
  image_convert(colorspace = "cmyk") |>
  image_channel(channel = "Black")

# Combine the magenta and black channels by averaging them
im_combined <- image_composite(im_magenta, im_black, operator = "plus")

# Apply a lower blur and threshold with finer values
im_threshold <- im_combined |>
  image_blur(radius = 0, sigma = 0.8) |>
  image_threshold(type = "black", threshold = "10%") |>
  image_threshold(type = "white", threshold = "0.2%")

# Optional: Refine the mask to clean up small artifacts
im_refined <- im_threshold |>
  image_morphology(method = "Erode", kernel = "Disk:1")

# Combine the mask with the original image
mask <- im_refined |> image_transparent("black")
im_composite <- image_composite(mask, image)

# Save the resulting masked image as a PNG file
output_path <- "./30uM7738/analysis/wf-VISIUM/spaceranger_out_Run2_autoalign/outs/spatial/tissue_hires_image_whtbg.png"
image_write(im_composite, path = output_path, format = "png")

# Optionally display the original and masked images
par(mfrow = c(1, 2), mar = c(0, 0, 0, 0))
image |> as.raster() |> plot()
im_composite |> as.raster() |> plot()
```

## Load Your Sample Data (Visium)

```{r step4_load_visium}
# Create Giotto object using your Visium data
SpatialTrans_30uM7738  <- createGiottoVisiumObject(
  visium_dir = data_dir_10x_30uM7738,  # Use the root directory of the Visium data
  expr_data = "raw",               # Use "filtered" or "raw" based on your preference
  png_name = "tissue_hires_image_whtbg.png", #use White background remove whtbg from file if want to use original image
  gene_column_index = 2,           # Default column for gene names
  instructions = instrs            # Use the instructions we created
)

# Print a summary of the Giotto object
print(SpatialTrans_30uM7738 )
```


# Remove spots that are not in the data
```{r step4b_remove_extra_spots}
# Step 1: Load ONT gene expression data
# --------------------------------------
SpatialTrans_30uM7738_ONTgene <- get10Xmatrix(
  "./30uM7738/analysis/wf-VISIUM/SR1040-610_30uM7738/gene_raw_feature_bc_matrix", 
  gene_column_index = 2
)
# Get the cell IDs from both objects
ont_cell_ids <- colnames(SpatialTrans_30uM7738_ONTgene)
original_cell_ids <- SpatialTrans_30uM7738@cell_ID[["cell"]]

# Identify the extra cell in the ONT data
extra_cell <- setdiff(ont_cell_ids, original_cell_ids)
print(extra_cell)  # This should print the extra cell ID(s)
# Remove the extra cell from ONT data
SpatialTrans_30uM7738_ONTgene <- SpatialTrans_30uM7738_ONTgene[, !(colnames(SpatialTrans_30uM7738_ONTgene) %in% extra_cell)]

```

# REPLACE WITH ONT GENE Data

```{r step4c_replace_ont}

# Step 2: Get spatial locations from the original Giotto object
# ------------------------------------------------------------
spatlocs <- getSpatialLocations(gobject = SpatialTrans_30uM7738, 
                                output = "spatLocsObj")

# Step 3: Create a new Giotto object with ONT gene expression and spatial locations
# --------------------------------------------------------------------------------
SpatialTrans_30uM7738_ONTgene <- createGiottoObject(
  expression = SpatialTrans_30uM7738_ONTgene, 
  spatial_locs = spatlocs,
  instructions = instrs            # Use the instructions we created
)

# Step 4: Transfer the image from the original Giotto object
# ----------------------------------------------------------
hiResG_img <- getGiottoImage(SpatialTrans_30uM7738)  # Get the image from the original object

SpatialTrans_30uM7738_ONTgene <- addGiottoImage(
  gobject = SpatialTrans_30uM7738_ONTgene, 
  images = list(hiResG_img)
)

# Step 5: Transfer cell metadata from the original object
# -------------------------------------------------------
SpatialTrans_30uM7738_ONTgene@cell_metadata$cell$rna@metaDT <- 
  SpatialTrans_30uM7738@cell_metadata$cell$rna@metaDT

# Step 6: Transfer spatial information from the original object
# -------------------------------------------------------------
SpatialTrans_30uM7738_ONTgene@spatial_info <- SpatialTrans_30uM7738@spatial_info

# Step 7: Verify the updated Giotto object
# ----------------------------------------
str(SpatialTrans_30uM7738_ONTgene)  # Check the structure of the new object

# Print summary of the updated Giotto object
print(SpatialTrans_30uM7738_ONTgene)

# Optional: Verify dimensions of the new expression matrix
print(dim(SpatialTrans_30uM7738_ONTgene@expression[["cell"]][["rna"]][["raw"]]@exprMat))

```

# Save the Object and Load Object
```{r step4d_save_object}
saveGiotto(SpatialTrans_30uM7738_ONTgene, "./GiottoSuite_30uM7738_ONTgene", overwrite = TRUE)

```

#

```{r step4e_load_object}
SpatialTrans_30uM7738_ONTgene <- loadGiotto("./GiottoSuite_30uM7738_ONTgene")
```

# Step 4: Visualize spots covered by tissue, save the plot as 'SpatPlot2_in_tissue.png', and display it

## Use the metadata column “in_tissue” to highlight the spots corresponding to the tissue area.
```{r step5_in_tissue_plot}

# Define the save parameters
base_save_parameters <- list(
  save_dir = results_folder,  # Directory where the plots will be saved
  save_format = "png",        # Save as PNG format
  units = "in",               # Units for width and height (inches)
  base_width = 10,             # Width of the plot
  base_height = 10,            # Height of the plot
  dpi = 600                   # Resolution (DPI)
)

# Create the plot, save it as 'SpatPlot2_in_tissue.png', and return it for display
SpatPlot2_in_tissue <- spatPlot2D(
  gobject = SpatialTrans_30uM7738_ONTgene,
  cell_color = "in_tissue",
  point_alpha = 0.5,         # Set transparency for better visualization
  point_size = 3,
  cell_color_code = c("0" = "lightgrey", "1" = "blue"),
  show_image = TRUE,               # Show the underlying image
  save_plot = TRUE,                # Save the plot
  save_param = base_save_parameters,    # Apply the save parameters
  return_plot = TRUE,               # Return the plot object to display after saving
  default_save_name = "SpatPlot2_in_tissue"  # Save plot with this name
)

# Display the plot as 'SpatPlot2_in_tissue'
print(SpatPlot2_in_tissue)

# Subset spots based on the "in_tissue" metadata and create a subsetted Giotto object

# Get metadata from the Giotto object
metadata <- getCellMetadata(gobject = SpatialTrans_30uM7738_ONTgene, output = "data.table")

# Subset spots that are within the tissue area
in_tissue_barcodes <- metadata[in_tissue == 1]$cell_ID

# Subset the Giotto object to include only the spots within the tissue
SpatialTrans_30uM7738_ONTgene_tissue <- subsetGiotto(gobject = SpatialTrans_30uM7738_ONTgene, cell_ids = in_tissue_barcodes)

# Print a summary of the subsetted Giotto object
print(SpatialTrans_30uM7738_ONTgene_tissue)
print(dim(SpatialTrans_30uM7738_ONTgene_tissue@expression[["cell"]][["rna"]][["raw"]]@exprMat))



```


# Step 5 Quality control
Statistics
Use the function addStatistics() to count the number of features per spot. The statistics information will be stored in the metadata table under the new column “nr_feats”. Then, use this column to visualize the number of features per spot across the sample.

```{r step5a_qc_statistics}
# Add statistics to the Giotto object
SpatialTrans_30uM7738_ONTgene_statistics <- addStatistics(
  gobject = SpatialTrans_30uM7738_ONTgene,
  expression_values = "raw"
)
```

## Step 5a1: Compute Mitochondrial and Ribosomal QC Metrics

```{r step5a1_mito_ribo_qc}
# Get raw expression matrix for QC calculations
expr_matrix <- getExpression(SpatialTrans_30uM7738_ONTgene_statistics, 
                              values = "raw", 
                              output = "matrix")

# Identify mitochondrial genes (MT- prefix)
mito_genes <- rownames(expr_matrix)[grep("^MT-", rownames(expr_matrix))]
cat("Mitochondrial genes detected:", length(mito_genes), "\n")
cat("Genes:", paste(mito_genes, collapse = ", "), "\n\n")

# Identify ribosomal genes (RPL and RPS prefix)
ribo_genes <- rownames(expr_matrix)[grep("^RP[LS]", rownames(expr_matrix))]
cat("Ribosomal genes detected:", length(ribo_genes), "\n")

# Calculate total counts per spot
total_counts <- colSums(expr_matrix)

# Calculate mitochondrial percentage
mito_counts <- colSums(expr_matrix[mito_genes, , drop = FALSE])
pct_mito <- (mito_counts / total_counts) * 100

# Calculate ribosomal percentage
ribo_counts <- colSums(expr_matrix[ribo_genes, , drop = FALSE])
pct_ribo <- (ribo_counts / total_counts) * 100

# Add QC metrics to cell metadata
cell_meta <- getCellMetadata(SpatialTrans_30uM7738_ONTgene_statistics, output = "data.table")
cell_meta[, pct_mito := pct_mito[match(cell_ID, names(pct_mito))]]
cell_meta[, pct_ribo := pct_ribo[match(cell_ID, names(pct_ribo))]]

# Update Giotto object with new metadata
SpatialTrans_30uM7738_ONTgene_statistics <- addCellMetadata(
  gobject = SpatialTrans_30uM7738_ONTgene_statistics,
  new_metadata = cell_meta[, .(cell_ID, pct_mito, pct_ribo)],
  by_column = TRUE,
  column_cell_ID = "cell_ID"
)

# Print QC Summary
cat("\n=== Pre-filter QC Summary (30uM NUC-7738 Treated) ===\n")
cat("Total spots:", length(total_counts), "\n")
cat("\n%Mitochondrial distribution:\n")
print(summary(pct_mito))
cat("\n%Ribosomal distribution:\n")
print(summary(pct_ribo))
cat("\nTotal counts per spot:\n")
print(summary(total_counts))
```

## Step 5a2: Visualize %Mito and %Ribo Spatially

```{r step5a2_mito_ribo_plots}
# Spatial plot of %Mito
SpatPlot2_pct_mito <- spatPlot2D(
  gobject = SpatialTrans_30uM7738_ONTgene_statistics,
  cell_color = "pct_mito",
  point_size = 3,
  show_image = TRUE,
  color_as_factor = FALSE,
  cell_color_gradient = c("white", "orange", "red"),
  save_plot = TRUE,
  save_param = base_save_parameters,
  return_plot = TRUE,
  default_save_name = "SpatPlot2_QC_pct_mito"
)
print(SpatPlot2_pct_mito)

# Spatial plot of %Ribo
SpatPlot2_pct_ribo <- spatPlot2D(
  gobject = SpatialTrans_30uM7738_ONTgene_statistics,
  cell_color = "pct_ribo",
  point_size = 3,
  show_image = TRUE,
  color_as_factor = FALSE,
  cell_color_gradient = c("white", "lightblue", "blue"),
  save_plot = TRUE,
  save_param = base_save_parameters,
  return_plot = TRUE,
  default_save_name = "SpatPlot2_QC_pct_ribo"
)
print(SpatPlot2_pct_ribo)

# Distribution histograms
par(mfrow = c(1, 2))
hist(pct_mito, breaks = 50, main = "Distribution of %Mito (30uM Treated)", xlab = "%Mitochondrial", col = "salmon")
abline(v = median(pct_mito), col = "red", lwd = 2, lty = 2)
hist(pct_ribo, breaks = 50, main = "Distribution of %Ribo (30uM Treated)", xlab = "%Ribosomal", col = "lightblue")
abline(v = median(pct_ribo), col = "blue", lwd = 2, lty = 2)
par(mfrow = c(1, 1))
```

## Step 5a3: Standard QC Visualization

```{r step5a3_qc_nr_feats}
# Visualize the number of features per spot (nr_feats) and save the plot
SpatPlot2_QC_nr_feats <- spatPlot2D(
  gobject = SpatialTrans_30uM7738_ONTgene_statistics,
  cell_color = "nr_feats",           # Color based on the number of features (genes) per spot
  point_size = 3,
  show_image = TRUE,                 # Show the underlying image
  color_as_factor = FALSE,           # Use a continuous color scale (not a factor)
  save_plot = TRUE,                  # Save the plot
  save_param = base_save_parameters,   # Apply the save parameters
  return_plot = TRUE,                 # Return the plot object to display after saving
  default_save_name = "SpatPlot2_QC_nr_feats"  # Save plot with this name
)

# Display the QC plot
print(SpatPlot2_QC_nr_feats)

```

```{r step5b_qc_total_expr}

# Visualize the number of features per spot (nr_feats) and save the plot
SpatPlot2_total_expr <- spatPlot2D(
  gobject = SpatialTrans_30uM7738_ONTgene_statistics,
  cell_color = "total_expr",           # Color based on the number of features (genes) per spot
  point_size = 3,
  show_image = TRUE,                 # Show the underlying image
  color_as_factor = FALSE,           # Use a continuous color scale (not a factor)
  save_plot = TRUE,                  # Save the plot
  save_param = base_save_parameters,   # Apply the save parameters
  return_plot = TRUE,                 # Return the plot object to display after saving
  default_save_name = "SpatPlot2_QC_total_expr"  # Save plot with this name
)

# Display the QC plot
print(SpatPlot2_total_expr)

```

# Step 5b: Distribution of features per spot and filtering

```{r step5c_filter_distribution}

# Filter distribution by cells
Dist_cells <- filterDistributions(
  gobject = SpatialTrans_30uM7738_ONTgene_statistics, 
  detection = "cells",               # Detect based on cells
  save_param = base_save_parameters,  # Save the plot
  default_save_name = "Dist_cells"  # Save plot with this name
)

# Display the plot
print(Dist_cells)
```

```{r step5d_dist_feats}

# Filter distribution by features
Dist_feats <- filterDistributions(
  gobject = SpatialTrans_30uM7738_ONTgene_statistics, 
  detection = "feats",               # Detect based on features
  save_param = base_save_parameters,  # Save the plot
  default_save_name = "Dist_feats"  # Save plot with this name
)

# Display the plot
print(Dist_feats)

```


```{r step5e_filter_combinations}
# Filter combinations of detection thresholds
Comb_thresholds <- filterCombinations(
  gobject = SpatialTrans_30uM7738_ONTgene_statistics,
  expression_thresholds = c(1, 2, 3, 4),        # Expression thresholds
  feat_det_in_min_cells = c(1, 10, 100, 1000),   # Minimum detected features in cells
  min_det_feats_per_cell = c(200, 400, 800, 1600), # Minimum detected features per cell
  save_param = base_save_parameters,  # Save the plot
  default_save_name = "Comb_thresholds"  # Save plot with this name
)

```

# Run filtering strategies interactively

```{r step5f_interactive_filter}
# Source the external Shiny app script
source("./scripts/giotto_interactive_filter.R")

```

# Step 6: Apply a filtering strategy for analysis and continue with the same object

```{r step6_filter_normalize}
# Define filtering parameters as variables
expression_threshold <- 1.5
feat_det_in_min_spots <- 50  # Reducing this leads to differential expression of few spots ie features in smaller spots
min_det_feats_per_spot <- 550

# Filter the Giotto object directly into SpatialTrans_30uM7738_ONTgene_fil
SpatialTrans_30uM7738_ONTgene <- filterGiotto(
  gobject = SpatialTrans_30uM7738_ONTgene,
  expression_threshold = expression_threshold,
  feat_det_in_min_cells = feat_det_in_min_spots,
  min_det_feats_per_cell = min_det_feats_per_spot,
  expression_values = "raw",
  verbose = TRUE
)

# Normalize the Giotto object with a specified scale factor (default 6000)
SpatialTrans_30uM7738_ONTgene <- normalizeGiotto(
  gobject = SpatialTrans_30uM7738_ONTgene,
  scalefactor = 6000,
  verbose = TRUE
)

# Add statistics for visualization
SpatialTrans_30uM7738_ONTgene <- addStatistics(
  gobject = SpatialTrans_30uM7738_ONTgene,
  expression_values = "raw"
)

# Create the QC plot after filtering
SpatPlot2_QC_afterfiltering <- spatPlot2D(
  gobject = SpatialTrans_30uM7738_ONTgene,
  cell_color = "total_expr",
  point_size = 6,
  show_image = TRUE,
  point_alpha = 0.7,
  color_as_factor = FALSE,
  cell_color_gradient = c("#f6d9d9", "#fb0000"),
  save_plot = FALSE,  # Disable auto-save
  return_plot = TRUE
)

SpatPlot2_QC_afterfiltering_gg <- SpatPlot2_QC_afterfiltering + 
  # Add the title above the bullet points in the bottom-right corner
  annotate(
    "text", 
    x = Inf, y = -Inf, 
    label = "Spots Filtering Criteria",  # Title
    hjust = 1.1, vjust = -12.5, size = 5, color = "black", fontface = "bold"  # Slightly above the bullet points
  ) +
  # Add the bullet points in the bottom-right corner
  annotate(
    "text", 
    x = Inf, y = -Inf, 
    label = paste0(
      "• In-tissue marked spots\n",  # First bullet point
      "• Expression threshold: ", expression_threshold, "\n",  # Second bullet point
      "• Feature detection in min spots: ", feat_det_in_min_spots, "\n",  # Third bullet point
      "• Min detected features per spot: ", min_det_feats_per_spot  # Fourth bullet point
    ),
    hjust = 1.1, vjust = -1.1, size = 4, color = "black", fontface = "plain"  # Left-align bullet points
  )

# Define the save directory
save_directory <- "./results/Giotto_30uM7738_results/ONTgene/"

# Save the updated plot with annotations to the specified directory
ggsave(
  filename = file.path(save_directory, "SpatPlot2_QC_afterfiltering_with_annotations.png"),
  plot = SpatPlot2_QC_afterfiltering_gg, 
  width = 10, height = 10, dpi = 600
)

# Display the updated plot
print(SpatPlot2_QC_afterfiltering_gg)


```

## Step 6a: Post-filter %Mito and %Ribo QC (Sensitivity Analysis)

```{r step6a_postfilter_mito_ribo}
# Re-compute %Mito and %Ribo after filtering for sensitivity analysis
expr_matrix_post <- getExpression(SpatialTrans_30uM7738_ONTgene, 
                                   values = "raw", 
                                   output = "matrix")

# Get gene lists
mito_genes_post <- rownames(expr_matrix_post)[grep("^MT-", rownames(expr_matrix_post))]
ribo_genes_post <- rownames(expr_matrix_post)[grep("^RP[LS]", rownames(expr_matrix_post))]

# Calculate metrics
total_counts_post <- colSums(expr_matrix_post)
mito_counts_post <- colSums(expr_matrix_post[mito_genes_post, , drop = FALSE])
ribo_counts_post <- colSums(expr_matrix_post[ribo_genes_post, , drop = FALSE])
pct_mito_post <- (mito_counts_post / total_counts_post) * 100
pct_ribo_post <- (ribo_counts_post / total_counts_post) * 100

# Add to metadata
post_meta <- getCellMetadata(SpatialTrans_30uM7738_ONTgene, output = "data.table")
post_meta[, pct_mito := pct_mito_post[match(cell_ID, names(pct_mito_post))]]
post_meta[, pct_ribo := pct_ribo_post[match(cell_ID, names(pct_ribo_post))]]

SpatialTrans_30uM7738_ONTgene <- addCellMetadata(
  gobject = SpatialTrans_30uM7738_ONTgene,
  new_metadata = post_meta[, .(cell_ID, pct_mito, pct_ribo)],
  by_column = TRUE,
  column_cell_ID = "cell_ID"
)

# Print Post-filter QC Summary
cat("\n=== Post-filter QC Summary (30uM NUC-7738 Treated) ===\n")
cat("Remaining spots after QC filtering:", length(total_counts_post), "\n")
cat("\n%Mitochondrial distribution (post-filter):\n")
print(summary(pct_mito_post))
cat("\n%Ribosomal distribution (post-filter):\n")
print(summary(pct_ribo_post))

# Visualize post-filter %Mito spatially
SpatPlot2_pct_mito_postfilter <- spatPlot2D(
  gobject = SpatialTrans_30uM7738_ONTgene,
  cell_color = "pct_mito",
  point_size = 4,
  show_image = TRUE,
  color_as_factor = FALSE,
  cell_color_gradient = c("white", "orange", "red"),
  save_plot = TRUE,
  save_param = base_save_parameters,
  return_plot = TRUE,
  default_save_name = "SpatPlot2_QC_pct_mito_postfilter"
)
print(SpatPlot2_pct_mito_postfilter)

# Visualize post-filter %Ribo spatially
SpatPlot2_pct_ribo_postfilter <- spatPlot2D(
  gobject = SpatialTrans_30uM7738_ONTgene,
  cell_color = "pct_ribo",
  point_size = 4,
  show_image = TRUE,
  color_as_factor = FALSE,
  cell_color_gradient = c("white", "lightblue", "blue"),
  save_plot = TRUE,
  save_param = base_save_parameters,
  return_plot = TRUE,
  default_save_name = "SpatPlot2_QC_pct_ribo_postfilter"
)
print(SpatPlot2_pct_ribo_postfilter)
```

# Step 8: Highly Variable Features (HVF)

```{r step8_hvf}
# Calculate HVF using loess regression
SpatialTrans_30uM7738_ONTgene <- calculateHVF(
  gobject = SpatialTrans_30uM7738_ONTgene,
  method = "cov_loess",               # Loess regression method
  save_plot = TRUE,                   # Save the plot
  show_plot = TRUE,                   # Show the plot
  default_save_name = "HVFplot_loess"  # Save plot with this name
)

# Calculate HVF using Pearson residuals
SpatialTrans_30uM7738_ONTgene <- calculateHVF(
  gobject = SpatialTrans_30uM7738_ONTgene,
  method = "var_p_resid",             # Pearson residuals method
  save_plot = TRUE,                   # Save the plot
  show_plot = TRUE,                   # Show the plot
  default_save_name = "HVFplot_pearson"  # Save plot with this name
)

# Calculate HVF using binned (covariance groups)
SpatialTrans_30uM7738_ONTgene <- calculateHVF(
  gobject = SpatialTrans_30uM7738_ONTgene,
  method = "cov_groups",              # Binned method
  save_plot = TRUE,                   # Save the plot
  show_plot = TRUE,                   # Show the plot 
  default_save_name = "HVFplot_binned"  # Save plot with this name
)

```

# Step 9a Principal Component Analysis (PCA)
## 9a. Run PCA Using HVFs

```{r step9a_pca}
# Set seed for reproducibility
set.seed(123)

# Step 9: Run PCA using highly variable features
SpatialTrans_30uM7738_ONTgene <- runPCA(
  gobject = SpatialTrans_30uM7738_ONTgene
)

# Visualize the percentage of variance explained by each principal component
screePlot_30uM7738 <- screePlot(
  gobject = SpatialTrans_30uM7738_ONTgene,
  ncp = 30,                       # Number of principal components to display
  save_plot = TRUE,                # Save the plot
  save_param = base_save_parameters,   # Apply the save parameters
  default_save_name = "ScreePlot_PCA"  # Save plot with this name
)

# Display the scree plot
print(screePlot_30uM7738)

```

## 9a. Run PCA Using HVFs
```{r step9b_custom_pca}
# Extract the top 100 features for custom PCA
my_features <- head(
  getFeatureMetadata(SpatialTrans_30uM7738_ONTgene, output = "data.table")$feat_ID, 
  500
)

# Run PCA with the custom selected features
SpatialTrans_30uM7738_ONTgene <- runPCA(
  gobject = SpatialTrans_30uM7738_ONTgene,
  feats_to_use = my_features,
  name = "custom_pca",
  ncp = 7  # Retain only the top 6 PCs
)

# Visualize the PCA plot using highly variable features (HVFs)
PCAplot_HVFs <- plotPCA(
  gobject = SpatialTrans_30uM7738_ONTgene,
  save_plot = TRUE,                # Save the plot
  save_param = base_save_parameters,   # Apply the save parameters
  default_save_name = "PCAplot_HVFs",  # Save plot with this name
  point_size = 4
)

# Display the PCA plot
print(PCAplot_HVFs)

# Visualize the custom PCA plot using the selected features
PCAplot_custom <- plotPCA(
  gobject = SpatialTrans_30uM7738_ONTgene,
  dim_reduction_name = "custom_pca",  # Use the custom PCA
  save_plot = TRUE,                   # Save the plot
  save_param = base_save_parameters,  # Apply the save parameters
  default_save_name = "PCAplot_custom",  # Save plot with this name
  point_size = 4
)

# Display the custom PCA plot
print(PCAplot_custom)

```

# Step 10: Run t-SNE and UMAP
 ## 10a. Run t-UMAP
```{r step10a_umap}

# Run UMAP on the first 10 principal components
SpatialTrans_30uM7738_ONTgene <- runUMAP(
  gobject = SpatialTrans_30uM7738_ONTgene,
  dimensions_to_use = 1:7,          # Use the first 10 dimensions
  verbose = TRUE
)

# Visualize the UMAP plot
UMAPplot <- plotUMAP(
  gobject = SpatialTrans_30uM7738_ONTgene,
  save_plot = TRUE,                  # Save the plot
  save_param = base_save_parameters,   # Apply the save parameters
  default_save_name = "UMAPplot_PCA10",  # Save plot with this name
  point_size = 4
)

# Display the UMAP plot
print(UMAPplot)
```
 ## 10b. Run t-SNE

```{r step10b_tsne}

# Run t-SNE on the first 10 principal components
SpatialTrans_30uM7738_ONTgene <- runtSNE(
  gobject = SpatialTrans_30uM7738_ONTgene,
  dimensions_to_use = 1:7,          # Use the first 10 dimensions
  verbose = TRUE
)

# Visualize the t-SNE plot
tSNEplot <- plotTSNE(
  gobject = SpatialTrans_30uM7738_ONTgene,
  save_plot = TRUE,                  # Save the plot
  save_param = base_save_parameters,   # Apply the save parameters
  default_save_name = "tSNEplot_PCA10",  # Save plot with this name
  point_size = 4
)

# Display the t-SNE plot
print(tSNEplot)
```

# 11 Clustering
```{r step11_create_network}
# Set seed for reproducibility
set.seed(123)

# Create a sNN network (default)
SpatialTrans_30uM7738_ONTgene <- createNearestNetwork(gobject = SpatialTrans_30uM7738_ONTgene, 
                                     dimensions_to_use = 1:7, 
                                     k = 20)
# Create a kNN network
SpatialTrans_30uM7738_ONTgene <- createNearestNetwork(gobject = SpatialTrans_30uM7738_ONTgene, 
                                     dimensions_to_use = 1:7, 
                                     k = 20,
                                     type = "kNN")

```


# Step 12: Leiden Clustering
 ## Plot in PCA Space
```{r step12a_leiden_pca}
# Set seed for reproducibility
set.seed(123)

# Step 12: Calculate Leiden clustering with a resolution of 0.4
SpatialTrans_30uM7738_ONTgene <- doLeidenCluster(
  gobject = SpatialTrans_30uM7738_ONTgene,
  resolution = 1,           # Resolution for clustering Try 1.0 if too many cluserts drop 
  n_iterations = 1000,        # Number of iterations
  nn_network_to_use = "sNN"   # Use the sNN or kNN network
)


# Visualize PCA plot colored by Leiden clusters
PCAplot_LeidenClusters <- plotPCA(
  gobject = SpatialTrans_30uM7738_ONTgene,
  cell_color = "leiden_clus",         # Color by Leiden clusters
  save_plot = TRUE,                   # Save the plot
  save_param = base_save_parameters,  # Apply the save parameters
  return_plot = TRUE, # Return the plot object to display after saving
  default_save_name = "plotPCA_LeidenClusters",  # Save plot with this name
  point_size = 4
)

# Display the PCA plot with Leiden clusters
print(PCAplot_LeidenClusters)

```

 ## Plot in UMAP Space
 ### Set the argument “show_NN_network = TRUE” to visualize the connections between spots.
```{r step12b_leiden_umap}
plotUMAP_LeidenClusters <- plotUMAP(gobject = SpatialTrans_30uM7738_ONTgene,
         cell_color = "leiden_clus", 
         show_NN_network = FALSE, 
         save_plot = TRUE,                   # Save the plot
         save_param = base_save_parameters,  # Apply the save parameters
         default_save_name = "plotUMAP_LeidenClusters",  # Save plot with this name
         point_size = 4)
      
print(plotUMAP_LeidenClusters)


plotUMAP_LeidenClusters_NN_network <- plotUMAP(gobject = SpatialTrans_30uM7738_ONTgene,
         cell_color = "leiden_clus", 
         show_NN_network = TRUE, 
         save_plot = TRUE,                   # Save the plot
         save_param = base_save_parameters,  # Apply the save parameters
         default_save_name = "plotUMAP_LeidenClusters_NN_network",  # Save plot with this name
         point_size = 4)
      
print(plotUMAP_LeidenClusters_NN_network )

```

## Plot in PCA Space
```{r step12c_leiden_tsne}
plottSNE_LeidenClusters <- plotTSNE(gobject = SpatialTrans_30uM7738_ONTgene,
         cell_color = "leiden_clus", 
         show_NN_network = FALSE, 
         save_plot = TRUE,                   # Save the plot
         save_param = base_save_parameters,  # Apply the save parameters
         default_save_name = "plottSNE_LeidenClusters",  # Save plot with this name
         point_size = 4)
      
print(plottSNE_LeidenClusters)


plottSNE_LeidenClusters_NN_network <- plotTSNE(gobject = SpatialTrans_30uM7738_ONTgene,
         cell_color = "leiden_clus", 
         show_NN_network = TRUE, 
         save_plot = TRUE,                   # Save the plot
         save_param = base_save_parameters,  # Apply the save parameters
         default_save_name = "plottSNE_LeidenClusters_NN_network",  # Save plot with this name
         point_size = 4)
      
print(plottSNE_LeidenClusters_NN_network)
```

## Step 12d Plot Leiden clusters spatially

```{r step12d_leiden_spatial}

# Create a QC plot after filtering, using the same SpatialTrans_30uM7738_ONTgene object
SpatPlot2_Leiden_clusters <- spatPlot2D(
  gobject = SpatialTrans_30uM7738_ONTgene,  # Use the same object with statistics
  cell_color = "leiden_clus",           # Color based on the number of features (genes) per spot
  point_size = 2.5,
  point_alpha = 0.5,
  show_image = TRUE,                 # Show the underlying image
  save_plot = TRUE,                  # Save the plot
  title = "",                        # Remove the title
  save_param = base_save_parameters,   # Apply the save parameters
  return_plot = TRUE,                 # Return the plot object to display after saving
  default_save_name = "SpatPlot2_Leiden_clusters"  # Save plot with this name
)

# Display the QC plot after filtering
print(SpatPlot2_Leiden_clusters)
```

# Visium Spatial Transcriptomics Analysis WorkShop II

# Step 13: Differential Expression Analysis

## Scran Markers
 The Scran method is preferred for robust differential expression analysis, especially when addressing technical variability or differences in sequencing depth across spatial locations.

Calculate the top marker genes per cluster using the scran method
```{r step13a_scran_markers}
scran_markers <- findMarkers_one_vs_all(gobject = SpatialTrans_30uM7738_ONTgene,
                                       method = "scran",
                                       expression_values = "normalized",
                                       cluster_column = "leiden_clus",
                                       min_feats = 10)

# Filter for upregulated genes only (logFC > 0)
scran_markers_up <- scran_markers[logFC > 0]

# Get top genes from upregulated markers only
topgenes_scran <- scran_markers_up[, head(.SD, 8), by = "cluster"]$feats
View(scran_markers)

```

### Visualize
Plot the normalized expression distribution of the top expressed genes.
```{r step13b_scran_violin}

violinPlot_scranMarker <- violinPlot(SpatialTrans_30uM7738_ONTgene, 
           feats = unique(topgenes_scran), 
           cluster_column = "leiden_clus",
           strip_text = 25, 
           axis_text_x_size = 30,
           axis_text_y_size = 15, 
           strip_position = "right",
           save_param = modifyList(base_save_parameters, list(base_width = 15, base_height = 30)),    # Override base width and heig 
           default_save_name = "violinPlot_scranMarker"  # Save plot with this name
)
           
print(violinPlot_scranMarker)
```

Heatmap
```{r step13c_scran_heatmap}
# Create a custom order for the leiden clusters
custom_order <- sort(unique(pDataDT(SpatialTrans_30uM7738_ONTgene)$leiden_clus))

# Create the heatmap with the custom cluster order for scran markers
heatmap_scranMarkers <- plotMetaDataHeatmap(
  SpatialTrans_30uM7738_ONTgene, 
  selected_feats = unique(topgenes_scran),
  metadata_cols = "leiden_clus",
  custom_cluster_order = custom_order,   # Apply custom cluster order
  x_text_size = 15, 
  y_text_size = 15,
  save_param = modifyList(base_save_parameters, list(base_width = 7, base_height = 12)),    # Override base width and height
  return_plot = TRUE,               # Return the plot object to display after saving
  default_save_name = "heatmap_scranMarkers"  # Save plot with this name
)

# Display the heatmap
print(heatmap_scranMarkers)
       
```

### Visualize the scaled expression spatial distribution of the top expressed genes across the sample.

```{r step13d_scran_spatial_dist}
Spatial_Dist_scranMarkers <- dimFeatPlot2D(SpatialTrans_30uM7738_ONTgene, 
              expression_values = "scaled",
              feats = sort(unique(topgenes_scran)),
              cow_n_col = 5, 
              point_size = 2.5,
              axis_title = 15,
              axis_text = 20,
              legend_text = 15,
              save_param = modifyList(base_save_parameters, list(base_width = 20, base_height = 20)),    # Override base width and height
              return_plot = TRUE,               # Return the plot object to display after saving
              default_save_name = "Spatial_Dist_scranMarkers"  # Save plot with this name
              )
print(Spatial_Dist_scranMarkers)
          
```

```{r step13e_scran_spatial_top}
#Spatial expression patterns of the top genes changed in the clusters

spatial_topscran_genes <- spatFeatPlot2D(SpatialTrans_30uM7738_ONTgene, 
               expression_values = "scaled",
               feats = topgenes_scran[1:10],
               show_image = TRUE, 
               cow_n_col = 5, 
               point_size = 2.5,
               point_alpha = 0.7,
               save_param = modifyList(base_save_parameters, list(base_width = 20, base_height = 10)),    # Override base width and height
               return_plot = TRUE,               # Return the plot object to display after saving
               default_save_name = "spatial_topscran_genes"  # Save plot with this name
               )
print(spatial_topscran_genes)
```


## Enrichr analysis of the top genes changed in the clusters


```{r step13f_scran_enrichr}
# Required Libraries
library(ggplot2)
library(cowplot)
library(stringr)  # To wrap text

# Get top 50 upregulated genes per cluster (using logFC > 0 filter)
top_genes_per_cluster <- scran_markers[logFC > 0, head(.SD, 50), by = cluster, .SDcols = "feats"]

# Define Enrichr libraries of interest
enrichr_libraries <- c("GO_Biological_Process_2023")

# Initialize a list to store enrichment results
enrichment_results <- list()

# Loop over each cluster and perform enrichment
for (cluster_id in unique(top_genes_per_cluster$cluster)) {
  
  # Extract the top 30 gene list for the current cluster
  gene_list <- top_genes_per_cluster[cluster == cluster_id, feats]
  
  # Perform enrichment analysis using Enrichr
  result <- enrichr(genes = gene_list, databases = enrichr_libraries)
  
  # Store the result for the cluster
  enrichment_results[[cluster_id]] <- result
  
  # Print a message to indicate completion of each cluster
  cat("Completed enrichment analysis for cluster:", cluster_id, "\n")
}

# Function to customize the plot and apply term wrapping
custom_plotEnrich <- function(cluster_result, cluster_id) {
  # Wrap the GO terms to two lines for better visibility
  cluster_result$Term <- str_wrap(cluster_result$Term, width = 50)
  
  plotEnrich(
    df = cluster_result, 
    showTerms = 5,             # Show top 5 pathways
    numChar = 90,              # Number of characters to show in pathway names
    y = "Count",               # Use count as y-axis
    orderBy = "P.value",       # Order by P-value
    title = paste("Cluster", cluster_id)
  ) + 
    theme_minimal() +                                 # Use minimal theme
    theme(
      axis.title.y = element_blank(),                 # Remove y-axis label
      panel.grid.major = element_blank(),             # Remove major grid
      panel.grid.minor = element_blank(),             # Remove minor grid
      plot.title = element_text(size = 14, face = "bold"),  # Bold title
      axis.text.x = element_text(size = 10),          # Font size for x-axis text
      axis.text.y = element_text(size = 10),          # Font size for y-axis text
      panel.border = element_blank(),                 # Remove border
      axis.line = element_line(),                     # Keep axis lines
      axis.ticks = element_line(),                    # Keep ticks
      plot.margin = margin(1, 1, 1, 3, "cm")          # Increase left margin to avoid cropping
    )
}

# Create individual plots for each cluster
plots <- list()
for (cluster_id in unique(top_genes_per_cluster$cluster)) {
  
  # Extract the enrichment results for the current cluster
  cluster_result <- enrichment_results[[cluster_id]][["GO_Biological_Process_2023"]]
  
  # Create the customized plot
  p <- custom_plotEnrich(cluster_result, cluster_id)
  
  # Add the plot to the list
  plots[[cluster_id]] <- p
}

# Combine all plots into one using cowplot, saved as GOBiologicalProcess_combined
GOBiologicalProcess_combined <- plot_grid(plotlist = plots, ncol = 1) +
  ggtitle("Top 5 GO Biological Process Pathways") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 16))  # Center title and adjust size

# Save the combined plot as a PNG with increased width to avoid cropping
ggsave(
  filename = "./figures/GOBiologicalProcess_combined.png",  # Save with a unique name
  plot = GOBiologicalProcess_combined,
  width = 15, height = 25, dpi = 600  # Adjust width, height, and DPI as needed
)

# Display the combined plot
print(GOBiologicalProcess_combined)


```
# Step 14 Enrichment & Deconvolution
Visium spatial transcriptomics does not provide single-cell resolution, making cell type annotation a harder problem. Giotto provides several ways to calculate enrichment of specific cell-type signature gene lists.


# Step 16 Spatial expression patterns
## Patial variable genes
Create a spatial network

```{r step16a_spatial_network}
SpatialTrans_30uM7738_ONTgene <- createSpatialNetwork(gobject = SpatialTrans_30uM7738_ONTgene,
                                     method = "kNN", 
                                     k = 30,
                                     maximum_distance_knn = 550,
                                     name = "spatial_network")
```

### Sav network plot

```{r step16b_network_plot}
# Function to generate and save the plot with different show_image values
save_spatPlot2D_with_show_image <- function(show_image_value, save_name_suffix) {
  spatPlot2D(
    gobject = SpatialTrans_30uM7738_ONTgene,  
    show_network = TRUE,
    network_color = "blue",
    show_image = show_image_value, 
    spatial_network_name = "spatial_network",
    save_param = base_save_parameters,    # Apply the save parameters
    return_plot = TRUE,               # Return the plot object to display after saving
    default_save_name = paste0("Spatial_Network_k_10_knn_550_", save_name_suffix)  # Append suffix to save name
  )
}

# Generate and save plots
Spatial_Network_with_image <- save_spatPlot2D_with_show_image(TRUE, "with_image")
Spatial_Network_without_image <- save_spatPlot2D_with_show_image(FALSE, "without_image")

# Display the plots
print(Spatial_Network_with_image)
print(Spatial_Network_without_image)

```


## Rank binarization
Rank the genes on the spatial dataset depending on whether they exhibit a spatial pattern location or not.

This step may take a few minutes to run.

```{r step16c_binspect}
ranktest <- binSpect(SpatialTrans_30uM7738_ONTgene, 
                     bin_method = "rank",
                     calc_hub = TRUE, 
                     hub_min_int = 5,
                     spatial_network_name = "spatial_network")

View(ranktest)
```
                
```{r step16d_binspect_enrichr}
# Convert ranktest to data.table (if it is not already)
ranktest <- as.data.table(ranktest)

# Filter for significant genes with p.value < 0.05
significant_genes <- ranktest[p.value < 0.05, .(feats)]

# Define Enrichr libraries of interest (you can customize this list)
enrichr_libraries <- c( "GO_Biological_Process_2021")

# Extract the gene list from the filtered data
gene_list <- significant_genes$feats

# Perform enrichment analysis using Enrichr
enrichment_results <- enrichr(genes = gene_list, databases = enrichr_libraries)

# Print the enrichment results
View(enrichment_results)

```

## Visualize top results
Plot the scaled expression of genes with the highest probability of being spatial genes.
```{r step16e_spatial_prob_genes}
spatial_prob_genes <- spatFeatPlot2D(SpatialTrans_30uM7738_ONTgene, 
               expression_values = "scaled",
               feats = ranktest$feats[9:16],
               show_image = TRUE, 
               cow_n_col = 4, 
               point_size = 2.5,
               point_alpha = 0.7,
               save_param = modifyList(base_save_parameters, list(base_width = 20, base_height = 10)),    # Override base width and height
               return_plot = TRUE,               # Return the plot object to display after saving
               default_save_name = "spatial_prob_9_16_genes"  # Save plot with this name
               )
print(spatial_prob_genes)
```

#  Spatial co-expression modules

### Cluster the top 500 spatial genes into 20 clusters
```{r step17a_detect_spatial_cor}
ext_spatial_genes <- ranktest[1:150,]$feats
 # Use detectSpatialCorGenes function to calculate pairwise distances between genes.
spat_cor_netw_DT <- detectSpatialCorFeats(
    SpatialTrans_30uM7738_ONTgene,
    method = "network",
    spatial_network_name = "spatial_network",
    subset_feats = ext_spatial_genes)
```
## Visualize
### Plot the scaled expression of the 3 genes with most similar spatial patterns to RPL32.

```{r step17b_spatial_corr_plot}
# Function to identify top correlated genes and save spatial correlation plot
generate_spatial_corr_plot <- function(gene, top_n = 8) {
  
  # Identify most similar spatially correlated genes for the input gene
  top_genes <- showSpatialCorFeats(spat_cor_netw_DT, 
                                   feats = gene, 
                                   show_top_feats = 20)
  
  # Generate the spatial correlation plot and save it
  plot <- spatFeatPlot2D(
    SpatialTrans_30uM7738_ONTgene, 
    expression_values = "scaled",
    feats = top_genes$variable[1:top_n],    # Use the top N correlated genes
    cow_n_col = 4,
    point_size = 2.5,
    point_alpha = 0.7,
    show_image = TRUE,                     # Show the underlying image
    save_param = modifyList(base_save_parameters, list(base_width = 20, base_height = 10)),    # Override base width and height
    return_plot = TRUE,                     # Return the plot object for display
    default_save_name = paste0("spatial_spatialCorr_", gene)  # Save with gene name
  )
  
  # Print the plot (optional)
  print(plot)
  
  return(plot)
}

# Example usage: Generate and save plot for the gene "MT-CO1"
spatial_spatialCorr_LCN2 <- generate_spatial_corr_plot("MT-ND2")

```



# Cluster spatial genes

```{r step17c_cluster_spatial}
spat_cor_netw_DT <- clusterSpatialCorFeats(spat_cor_netw_DT, 
                                           name = "spat_netw_clus", 
                                           k = 20)
```                                           
## Visualize clusters
### Plot the correlation of the top 500 spatial genes with their assigned cluster.
```{r step17d_correlation_heatmap}

correlation_heatmap <-heatmSpatialCorFeats(SpatialTrans_30uM7738_ONTgene,
                     spatCorObject = spat_cor_netw_DT,
                     use_clus_name = "spat_netw_clus",
                     heatmap_legend_param = list(title = NULL))
               
print(correlation_heatmap)
```


### Rank spatial correlated clusters and show genes for selected clusters
```{r step17e_rank_spatial_groups}
netw_ranks <- rankSpatialCorGroups(
  SpatialTrans_30uM7738_ONTgene,
  spatCorObject = spat_cor_netw_DT, 
  use_clus_name = "spat_netw_clus")

``` 
### Plot the correlation and number of spatial genes in each cluster.

```{r step17f_show_spatial_cor}
top_netw_spat_cluster <- showSpatialCorFeats(spat_cor_netw_DT, 
                                            use_clus_name = "spat_netw_clus",
                                            selected_clusters = 6, 
                                            show_top_feats = 1)
```

### Create the metagene enrichment score per co-expression cluster
```{r step17g_metagene}
cluster_genes_DT <- showSpatialCorFeats(spat_cor_netw_DT, 
                                        use_clus_name = "spat_netw_clus", 
                                        show_top_feats = 1)

cluster_genes <- cluster_genes_DT$clus 
names(cluster_genes) <- cluster_genes_DT$feat_ID

SpatialTrans_30uM7738_ONTgene <- createMetafeats(SpatialTrans_30uM7738_ONTgene, 
                                feat_clusters = cluster_genes, 
                                name = "cluster_metagene")
```

### Plot the spatial distribution of the metagene enrichment scores of each spatial co-expression cluster.
```{r step17h_metagene_spatial}
spatCellPlot(SpatialTrans_30uM7738_ONTgene,
             spat_enr_names = "cluster_metagene",
             cell_annotation_values = netw_ranks$clusters,
             point_size = 1, 
             cow_n_col = 5)
```

# Step 17: Spatially informed clusters


```{r step18a_coexpr_genes}
coexpr_dt <- data.table::data.table(
  genes = names(spat_cor_netw_DT$cor_clusters$spat_netw_clus),
  cluster = spat_cor_netw_DT$cor_clusters$spat_netw_clus)

data.table::setorder(coexpr_dt, cluster)

top30_coexpr_dt <- coexpr_dt[, head(.SD, 30) , by = cluster]

spatial_genes <- top30_coexpr_dt$genes
print(spatial_genes)

```


## Re-calculate the clustering

```{r step18b_recalc_clustering}
# Set seed for reproducibility
set.seed(123)

#Use the spatial genes to calculate again the principal components, umap, network and clustering
SpatialTrans_30uM7738_ONTgene <- runPCA(gobject = SpatialTrans_30uM7738_ONTgene,
                       feats_to_use = spatial_genes,
                       name = "custom_pca")

SpatialTrans_30uM7738_ONTgene <- runUMAP(SpatialTrans_30uM7738_ONTgene, 
                        dim_reduction_name = "custom_pca", 
                        dimensions_to_use = 1:5,
                        name = "custom_umap")

SpatialTrans_30uM7738_ONTgene <- createNearestNetwork(gobject = SpatialTrans_30uM7738_ONTgene,
                                     dim_reduction_name = "custom_pca",
                                     dimensions_to_use = 1:5, 
                                     k = 30,
                                     name = "custom_NN")

SpatialTrans_30uM7738_ONTgene <- doLeidenCluster(gobject = SpatialTrans_30uM7738_ONTgene, 
                                network_name = "custom_NN",
                                resolution = 1, 
                                n_iterations = 1000,
                                name = "custom_leiden")
```

### Visualize
### Plot the spatial distribution of the Leiden clusters calculated based on the spatial gene

```{r step18c_custom_leiden_spatial}
spatPlot2D(SpatialTrans_30uM7738_ONTgene, 
           cell_color = "custom_leiden",
           point_size = 3)
```

```{r step18d_custom_leiden_umap}
plotUMAP(gobject = SpatialTrans_30uM7738_ONTgene, 
         cell_color = "custom_leiden")


```

# Step 18: Spatial domains HMRF
## Hidden Markov Random Field (HMRF) models capture spatial dependencies and segment tissue regions based on shared and gene expression patterns.

### Do HMRF with different betas on top 30 genes per spatial co-expression module
This step may take several minutes to run.
```{r step19a_hmrf}
HMRF_spatial_genes <- doHMRF(gobject = SpatialTrans_30uM7738_ONTgene,
                            expression_values = "scaled",
                            spatial_genes = spatial_genes, 
                            k = 20,
                            spatial_network_name = "spatial_network",
                            betas = c(0, 10, 5),
                            output_folder = "./results/Giotto_30uM7738_results/11_HMRF/")
```
Add the HMRF results to the giotto object
```{r step19b_add_hmrf}
SpatialTrans_30uM7738_ONTgene <- addHMRF(gobject = SpatialTrans_30uM7738_ONTgene, 
                        HMRFoutput = HMRF_spatial_genes,
                        k = 20, 
                        betas_to_add = c(0, 10, 20, 30, 40),
                        hmrf_name = "HMRF")
```
## Visualize
### Plot the spatial distribution of the HMRF domains.
```{r step19c_hmrf_plot}
Spat_Plot_HMRF <-spatPlot2D(gobject = SpatialTrans_30uM7738_ONTgene, 
           cell_color = "HMRF_k20_b.40",
           point_size = 5.5,
           point_alpha = 0.7,
           show_image = TRUE,    
           save_param = base_save_parameters,
           return_plot = TRUE,
           default_save_name = "Spat_Plot_HMRF")

print(Spat_Plot_HMRF)
```        

# Step 19: Interactive Tools

We have integrated a shiny app in Giotto to interactively select regions of a spatial plot.

Create a spatial plot


```{r step20a_spatplot}
30uM7738_spatPlot <- spatPlot2D(gobject = SpatialTrans_30uM7738_ONTgene,
                          cell_color = "leiden_clus",
                          show_image = TRUE,
                          return_plot = TRUE,
                          point_size = 5,
                          point_alpha = 0.3)

30uM7738_spatPlot
```



```{r step20b_interactive_polygons}
plotInteractivePolygons(30uM7738_spatPlot)
```

### Select the regions of interest and save the coordinates
```{r step20c_polygon_coords}
polygon_coordinates <- plotInteractivePolygons(30uM7738_spatPlot)
```
### Transform the data.table or data.frame with coordinates into a Giotto polygon object

```{r step20d_create_polygons}
giotto_polygons <- createGiottoPolygonsFromDfr(polygon_coordinates, 
                                               name = "selections",
                                               calc_centroids = TRUE)
```
### Add the polygons to the Giotto object
```{r step20e_add_polygons}
SpatialTrans_30uM7738_ONTgene <- addGiottoPolygons(gobject = SpatialTrans_30uM7738_ONTgene,
                                  gpolygons = list(giotto_polygons))
```

### Add the corresponding polygon IDs to the cell metadata
```{r step20f_add_polygon_cells}
SpatialTrans_30uM7738_ONTgene <- addPolygonCells(SpatialTrans_30uM7738_ONTgene,
                                polygon_name = "selections")
```
### Extract the coordinates and IDs from cells located within one or multiple regions of interest
```{r step20g_get_cells_tumoroid}
getCellsFromPolygon(SpatialTrans_30uM7738_ONTgene,
                    polygon_name = "selections",
                    polygons = "tumoroid1")
```

###  If no polygon name is provided, the function will retrieve cells located within all polygons
```{r step20h_get_cells_all}
getCellsFromPolygon(SpatialTrans_30uM7738_ONTgene,
                    polygon_name = "selections")
```
### Compare the expression levels of some genes of interest between the selected regions
```{r step20i_compare_expression}
comparePolygonExpression(SpatialTrans_30uM7738_ONTgene,
                         selected_feats = c("B2M", "MT-CO1", "CD68"),)
``` 

### Calculate the top genes expressed within each region, then provide the result to compare polygons
```{r step20j_polygon_scran}
scran_results <- findMarkers_one_vs_all(
  SpatialTrans_30uM7738_ONTgene,
  spat_unit = "cell",
  feat_type = "rna",
  method = "scran",
  expression_values = "normalized",
  cluster_column = "selections",
  min_feats = 2)

top_genes <- scran_results[, head(.SD, 2), by = "cluster"]$feats

comparePolygonExpression(SpatialTrans_30uM7738_ONTgene,
                         selected_feats = top_genes)
```
##Compare the abundance of cell types between the selected region
```{r step20k_cell_abundance}
compareCellAbundance(SpatialTrans_30uM7738_ONTgene)
```

Use other columns within the cell metadata table to compare the cell type abundances

```{r step20l_cell_abundance_custom}
compareCellAbundance(SpatialTrans_30uM7738_ONTgene, 
                     cell_type_column = "custom_leiden")
```

### Use the spatPlot arguments to isolate and plot each region.

```{r step20m_spatplot_regions}
spatPlot2D(SpatialTrans_30uM7738_ONTgene,
           cell_color = "leiden_clus",
           group_by = "selections",
           show_image = TRUE,
           cow_n_col = 3,
           point_size = 2,
           show_legend = FALSE)
```

### Color each cell by cluster, cell type or expression level.

```{r step20n_feat_by_region}
spatFeatPlot2D(SpatialTrans_30uM7738_ONTgene,
               expression_values = "scaled",
               group_by = "selections",
               feats = "VIM",
               point_size = 7)
```

### Plot again the polygons
```{r step20o_plot_polygons}
plotPolygons(SpatialTrans_30uM7738_ONTgene,
             polygon_name = "selections",
             x = 30uM7738_spatPlot)

```
