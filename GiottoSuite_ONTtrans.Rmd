# Start libraries
```{r message=FALSE, warning=FALSE, echo=TRUE, eval=T, fig.height=4, fig.width=6}
# Load necessary libraries
library(Giotto)
library(dplyr)
library(ggplot2)
library(patchwork)
library(RColorBrewer)
library(terra)
library(exifr)

```

# Step 1: Load Full-Resolution Image and Extract Metadata
```{r}

# Load the full-resolution TIFF image using terra
data_dir_10x_DMSO <- "./DMSO/spaceranger_out_run2/outs"
fullres_image_path <- file.path(data_dir_10x_DMSO, "spatial/tissue_fullres_image.tif")
fullres_image <- rast(fullres_image_path)

# Extract metadata from the TIFF file using exifr
tiff_file_path <- file.path(data_dir_10x_DMSO, "spatial/tissue_fullres_image.tif")
metadata <- read_exif(tiff_file_path)

# Extract relevant fields: XResolution, YResolution, and ResolutionUnit
resolution_data <- metadata[, c("XResolution", "YResolution", "ResolutionUnit")]
microns_per_pixel <- 10000 / resolution_data$XResolution  # Convert pixels per cm to microns per pixel
print(paste("Microns per pixel:", microns_per_pixel))

# Check the original dimensions of the full-resolution image
fullres_dims <- dim(fullres_image)[1:2]
print(fullres_dims)
```

# Step 2: Downsample Image and Calculate Scaling Factor
```{r}
# Load the necessary library to read and write JSON files
library(jsonlite)

# Downsample the image using terra
downsample_factor <- 5 # Adjust as needed
fullres_image_downsampled <- aggregate(fullres_image, fact = downsample_factor)

# Save the downsampled image as a PNG
png_image_path <- file.path(data_dir_10x_DMSO, "spatial/tissue_hires_image.png")
writeRaster(fullres_image_downsampled, filename = png_image_path, overwrite = TRUE)

# Calculate the new hires scaling factor
new_hires_scale <- dim(fullres_image_downsampled)[1] / fullres_dims[1]
print(paste("New hires scale factor:", new_hires_scale))

# Load the original scalefactors_json.json
scalefactor_json_path <- file.path(data_dir_10x_DMSO, "spatial/scalefactors_json.json")
scalefactors <- fromJSON(scalefactor_json_path)

# Ensure all elements are numeric, and update the hires scale factor
scalefactors$tissue_hires_scalef <- as.numeric(new_hires_scale)

# Optionally, print the updated scalefactors to verify
print(scalefactors)

# Write the updated JSON back to the file with correct structure
write_json(scalefactors, scalefactor_json_path, pretty = TRUE, auto_unbox = TRUE)

# Verify the updated JSON file
print(paste("Updated scalefactors written to:", scalefactor_json_path))

```

# Step 3 Create the Giotto object
## createGiottoVisiumObject() will look for the standardized files organization from the visium technology in the data folder and will automatically load the expression and spatial information to create the Giotto object.

```{r}

# Set the Python path to the existing environment
python_path <- "/home/mustafa/miniforge3/envs/giotto_env/bin/python"

# Set up Giotto instructions with the manually specified Python path
results_folder <- "./results/Giotto_DMSO_results/ONTtranscripts"

# Create the results folder if it doesn't exist
if (!dir.exists(results_folder)) {
  dir.create(results_folder, recursive = TRUE)
}

# Create Giotto instructions with Python path
instrs <- createGiottoInstructions(
  save_plot = TRUE, 
  save_dir = results_folder, 
  show_plot = FALSE, 
  python_path = python_path
)

# Check instructions to confirm the setup
print(instrs)

```

## Load Your Sample Data (Visium)

```{r}
#Whiter backgroum image
png_image_relative_path <- "tissue_hires_image_whtbg.png"

# Create Giotto object using your Visium data
SpatialTrans_DMSO <- createGiottoVisiumObject(
  visium_dir = data_dir_10x_DMSO,  # Use the root directory of the Visium data
  expr_data = "raw",               # Use "filtered" or "raw" based on your preference
  png_name = png_image_relative_path,       # Path to the downsampled PNG image
  gene_column_index = 2,           # Default column for gene names
  instructions = instrs            # Use the instructions we created
)

# Print a summary of the Giotto object
print(SpatialTrans_DMSO)
```

# REPLACE WITH ONT Transcript Data

```{r}
# Step 1: Load ONT transcriptomics data
# --------------------------------------
SpatialTrans_DMSO_ONTtrans <- get10Xmatrix(
  "./DMSO/SR1040-610_DMSO/transcript_raw_feature_bc_matrix", 
  gene_column_index = 2
)

# Step 2: Get spatial locations from the original Giotto object
# ------------------------------------------------------------
spatlocs <- getSpatialLocations(gobject = SpatialTrans_DMSO, 
                                output = "spatLocsObj")

# Step 3: Filter spatial locations based on available barcodes in expression data
# ------------------------------------------------------------------------------
# Get barcodes from the transcriptomics expression matrix
trans_barcodes <- colnames(SpatialTrans_DMSO_ONTtrans)

# Filter spatlocs to retain only those with matching barcodes
filtered_spatlocs <- spatlocs[spatlocs$cell_ID %in% trans_barcodes, ]

# Step 4: Create a new Giotto object with filtered spatial locations and transcript expression
# --------------------------------------------------------------------------------------------
SpatialTrans_DMSO_ONTtrans <- createGiottoObject(
  expression = SpatialTrans_DMSO_ONTtrans, 
  spatial_locs = filtered_spatlocs,
  instructions = instrs            # Use the instructions we created
)

# Step 5: Transfer the image from the original Giotto object
# ----------------------------------------------------------
hiResG_img <- getGiottoImage(SpatialTrans_DMSO)  # Get the image from the original object

SpatialTrans_DMSO_ONTtrans <- addGiottoImage(
  gobject = SpatialTrans_DMSO_ONTtrans, 
  images = list(hiResG_img)
)

# Step 6: Transfer cell metadata from the original object
# -------------------------------------------------------
# Filter the cell metadata to keep only the matching barcodes
SpatialTrans_DMSO_ONTtrans@cell_metadata$cell$rna@metaDT <- 
  SpatialTrans_DMSO@cell_metadata$cell$rna@metaDT[
    SpatialTrans_DMSO@cell_metadata$cell$rna@metaDT$cell_ID %in% trans_barcodes, ]

# Step 7: Transfer spatial information from the original object
# -------------------------------------------------------------
SpatialTrans_DMSO_ONTtrans@spatial_info <- SpatialTrans_DMSO@spatial_info

# Step 8: Verify the updated Giotto object
# ----------------------------------------
str(SpatialTrans_DMSO_ONTtrans)  # Check the structure of the new object

# Print summary of the updated Giotto object
print(SpatialTrans_DMSO_ONTtrans)

# Optional: Verify dimensions of the new expression matrix
print(dim(SpatialTrans_DMSO_ONTtrans@expression[["cell"]][["rna"]][["raw"]]@exprMat))



```

# # Step 4: Visualize spots covered by tissue, save the plot as 'SpatPlot2_in_tissue.png', and display it

## Use the metadata column “in_tissue” to highlight the spots corresponding to the tissue area.
```{r}

# Define the save parameters
base_save_parameters <- list(
  save_dir = results_folder,  # Directory where the plots will be saved
  save_format = "png",        # Save as PNG format
  units = "in",               # Units for width and height (inches)
  base_width = 10,             # Width of the plot
  base_height = 10,            # Height of the plot
  dpi = 600                   # Resolution (DPI)
)

# Create the plot, save it as 'SpatPlot2_in_tissue.png', and return it for display
SpatPlot2_in_tissue <- spatPlot2D(
  gobject = SpatialTrans_DMSO_ONTtrans,
  cell_color = "in_tissue",
  point_alpha = 0.7,         # Set transparency for better visualization
  point_size = 3,
  cell_color_code = c("0" = "lightgrey", "1" = "blue"),
  show_image = TRUE,               # Show the underlying image
  save_plot = TRUE,                # Save the plot
  save_param = base_save_parameters,    # Apply the save parameters
  return_plot = TRUE,               # Return the plot object to display after saving
  default_save_name = "SpatPlot2_in_tissue"  # Save plot with this name
)

# Display the plot as 'SpatPlot2_in_tissue'
print(SpatPlot2_in_tissue)

# Subset spots based on the "in_tissue" metadata and create a subsetted Giotto object

# Get metadata from the Giotto object
metadata <- getCellMetadata(gobject = SpatialTrans_DMSO_ONTtrans, output = "data.table")

# Subset spots that are within the tissue area
in_tissue_barcodes <- metadata[in_tissue == 1]$cell_ID

# Subset the Giotto object to include only the spots within the tissue
SpatialTrans_DMSO_ONTtrans_tissue <- subsetGiotto(gobject = SpatialTrans_DMSO_ONTtrans, cell_ids = in_tissue_barcodes)

# Print a summary of the subsetted Giotto object
print(SpatialTrans_DMSO_ONTtrans_tissue)


```

# Save the Object and Load Object
```{r}
saveGiotto(SpatialTrans_DMSO_ONTtrans, "./GiottoSuite_DMSO_ONTtrans", overwrite = TRUE)

```

# Load

```{r}
SpatialTrans_DMSO_ONTtrans <- loadGiotto("./GiottoSuite_DMSO_ONTtrans")
```

# Step 5 Quality control *Does not Work for Transcript counts
Statistics
Use the function addStatistics() to count the number of features per spot. The statistics information will be stored in the metadata table under the new column “nr_feats”. Then, use this column to visualize the number of features per spot across the sample.

```{r}
# Step 5: Add statistics and create a QC plot

# Add statistics to the Giotto object
SpatialTrans_DMSO_ONTtrans_statistics <- addStatistics(
  gobject = SpatialTrans_DMSO_ONTtrans,
  expression_values = "raw",  # Use raw expression values

)

# Visualize the number of features per spot (nr_feats) and save the plot
SpatPlot2_QC_nr_feats <- spatPlot2D(
  gobject = SpatialTrans_DMSO_ONTtrans_statistics,
  cell_color = "nr_feats",           # Color based on the number of features (genes) per spot
  point_size = 3,
  show_image = TRUE,                 # Show the underlying image
  color_as_factor = FALSE,           # Use a continuous color scale (not a factor)
  save_plot = TRUE,                  # Save the plot
  save_param = base_save_parameters,   # Apply the save parameters
  return_plot = TRUE,                 # Return the plot object to display after saving
  default_save_name = "SpatPlot2_QC_nr_feats"  # Save plot with this name
)

# Display the QC plot
print(SpatPlot2_QC_nr_feats)


# Visualize the number of features per spot (nr_feats) and save the plot
SpatPlot2_total_expr <- spatPlot2D(
  gobject = SpatialTrans_DMSO_ONTtrans_statistics,
  cell_color = "total_expr",           # Color based on the number of features (genes) per spot
  point_size = 3,
  show_image = TRUE,                 # Show the underlying image
  color_as_factor = FALSE,           # Use a continuous color scale (not a factor)
  save_plot = TRUE,                  # Save the plot
  save_param = base_save_parameters,   # Apply the save parameters
  return_plot = TRUE,                 # Return the plot object to display after saving
  default_save_name = "SpatPlot2_QC_nr_feats"  # Save plot with this name
)

# Display the QC plot
print(SpatPlot2_total_expr)

```

# Step 5b: Distribution of features per spot and filtering

```{r}

# Filter distribution by cells
Dist_cells <- filterDistributions(
  gobject = SpatialTrans_DMSO_ONTtrans_statistics, 
  detection = "cells",               # Detect based on cells
  save_param = base_save_parameters,  # Save the plot
  default_save_name = "Dist_cells"  # Save plot with this name
)

# Display the plot
print(Dist_cells)


# Filter distribution by features
Dist_feats <- filterDistributions(
  gobject = SpatialTrans_DMSO_ONTtrans_statistics, 
  detection = "feats",               # Detect based on features
  save_param = base_save_parameters,  # Save the plot
  default_save_name = "Dist_feats"  # Save plot with this name
)

# Display the plot
print(Dist_feats)


# Filter combinations of expression thresholds and save the plot
save_parameters_combinations <- modifyList(base_save_parameters, list(
  save_name = "Comb_thresholds"  # Short name for the plot
))

# Filter combinations of detection thresholds
Comb_thresholds <- filterCombinations(
  gobject = SpatialTrans_DMSO_ONTtrans_statistics,
  expression_thresholds = c(1, 2, 3, 4),        # Expression thresholds
  feat_det_in_min_cells = c(1, 10, 100, 1000),   # Minimum detected features in cells
  min_det_feats_per_cell = c(200, 400, 800, 1600), # Minimum detected features per cell
  save_param = base_save_parameters,  # Save the plot
  default_save_name = "Comb_thresholds"  # Save plot with this name
)

```

# Step 6: Apply a filtering strategy for analysis and continue with the same object

```{r}
# Subset spots that are within the tissue area
in_tissue_barcodes <- metadata[in_tissue == 1]$cell_ID
SpatialTrans_DMSO_ONTtrans <- subsetGiotto(gobject = SpatialTrans_DMSO_ONTtrans, cell_ids = in_tissue_barcodes)

# Define filtering parameters as variables
expression_threshold <- 1
feat_det_in_min_spots <- 4 # If more specific spots are need decrease value
min_det_feats_per_spot <- 100 # 410 alternative if above is 4

# Filter the Giotto object directly into SpatialTrans_DMSO_ONTtrans_fil
SpatialTrans_DMSO_ONTtrans <- filterGiotto(
  gobject = SpatialTrans_DMSO_ONTtrans,
  expression_threshold = expression_threshold,
  feat_det_in_min_cells = feat_det_in_min_spots,
  min_det_feats_per_cell = min_det_feats_per_spot,
  expression_values = "raw",
  verbose = TRUE
)

# Normalize the Giotto object with a specified scale factor (default 6000)
SpatialTrans_DMSO_ONTtrans <- normalizeGiotto(
  gobject = SpatialTrans_DMSO_ONTtrans,
  scalefactor = 6000,
  verbose = TRUE
)

# Add statistics for visualization
SpatialTrans_DMSO_ONTtrans <- addStatistics(
  gobject = SpatialTrans_DMSO_ONTtrans,
  expression_values = "raw"
)

# Create the QC plot after filtering
SpatPlot2_QC_afterfiltering <- spatPlot2D(
  gobject = SpatialTrans_DMSO_ONTtrans,
  cell_color = "total_expr",
  point_size = 5.5,
  show_image = TRUE,
  point_alpha = 0.7,
  color_as_factor = FALSE,
  cell_color_gradient = c("#f6d9d9", "#fb0000"),
  save_plot = FALSE,  # Disable auto-save
  return_plot = TRUE
)

# Add annotation text for the filtering parameters
SpatPlot2_QC_afterfiltering_gg <- SpatPlot2_QC_afterfiltering + 
  # Add the title above the bullet points in the bottom-right corner
  annotate(
    "text", 
    x = Inf, y = -Inf, 
    label = "Spots Filtering Criteria",  # Title
    hjust = 1.1, vjust = -12.5, size = 5, color = "black", fontface = "bold"  # Slightly above the bullet points
  ) +
  # Add the bullet points in the bottom-right corner
  annotate(
    "text", 
    x = Inf, y = -Inf, 
    label = paste0(
      "• In-tissue marked spots\n",  # First bullet point
      "• Expression threshold: ", expression_threshold, "\n",  # Second bullet point
      "• Feature detection in min spots: ", feat_det_in_min_spots, "\n",  # Third bullet point
      "• Min detected features per spot: ", min_det_feats_per_spot  # Fourth bullet point
    ),
    hjust = 1.1, vjust = -1.1, size = 4, color = "black", fontface = "plain"  # Left-align bullet points
  )

# Define the save directory
save_directory <- "./results/Giotto_DMSO_results/ONTtranscripts/"

# Save the updated plot with annotations to the specified directory
ggsave(
  filename = file.path(save_directory, "SpatPlot2_QC_afterfiltering_with_annotations.png"),
  plot = SpatPlot2_QC_afterfiltering_gg, 
  width = 10, height = 10, dpi = 600
)

# Display the updated plot
print(SpatPlot2_QC_afterfiltering_gg)


```

# Step 7: Normalize the Giotto object using a scale factor
```{r}
```

# Step 8: Highly Variable Features (HVF)

```{r}
# Calculate HVF using loess regression
SpatialTrans_DMSO_ONTtrans <- calculateHVF(
  gobject = SpatialTrans_DMSO_ONTtrans,
  method = "cov_loess",               # Loess regression method
  save_plot = TRUE,                   # Save the
  show_plot = TRUE,                   # Show plot
  default_save_name = "HVFplot_loess"  # Save plot with this name
)

# Calculate HVF using Pearson residuals
SpatialTrans_DMSO_ONTtrans <- calculateHVF(
  gobject = SpatialTrans_DMSO_ONTtrans,
  method = "var_p_resid",             # Pearson residuals method
  save_plot = TRUE,                   # Save the plot
  show_plot = TRUE,                   # Show plot
  default_save_name = "HVFplot_pearson"  # Save plot with this name
)

# Calculate HVF using binned (covariance groups)
SpatialTrans_DMSO_ONTtrans <- calculateHVF(
  gobject = SpatialTrans_DMSO_ONTtrans,
  method = "cov_groups",              # Binned method
  save_plot = TRUE,                   # Save the plot
  show_plot = TRUE,                   # Show plot
  default_save_name = "HVFplot_binned"  # Save plot with this name
)

```


# Step 9a Principal Component Analysis (PCA)
## 9a. Run PCA Using HVFs

```{r}
# Step 9: Run PCA using highly variable features
SpatialTrans_DMSO_ONTtrans <- runPCA(
  gobject = SpatialTrans_DMSO_ONTtrans
)

# Visualize the percentage of variance explained by each principal component
screePlot_DMSO <- screePlot(
  gobject = SpatialTrans_DMSO_ONTtrans,
  ncp = 30,                       # Number of principal components to display
  save_plot = TRUE,                # Save the plot
  save_param = base_save_parameters,   # Apply the save parameters
  default_save_name = "ScreePlot_PCA"  # Save plot with this name
)

# Display the scree plot
print(screePlot_DMSO)

```

## 9a. Run PCA Using HVFs
```{r}
# Extract the top 1000 features for custom PCA
my_features <- head(
  getFeatureMetadata(SpatialTrans_DMSO_ONTtrans, output = "data.table")$feat_ID, 
  1000
)

# Run PCA with the custom selected features
SpatialTrans_DMSO_ONTtrans <- runPCA(
  gobject = SpatialTrans_DMSO_ONTtrans,
  feats_to_use = my_features,
  name = "customPCA"
)

# Visualize the PCA plot using highly variable features (HVFs)
PCAplot_HVFs <- plotPCA(
  gobject = SpatialTrans_DMSO_ONTtrans,
  save_plot = TRUE,                # Save the plot
  save_param = base_save_parameters,   # Apply the save parameters
  default_save_name = "PCAplot_HVFs",  # Save plot with this name
  point_size = 4
)

# Display the PCA plot
print(PCAplot_HVFs)

# Visualize the custom PCA plot using the selected features
PCAplot_custom <- plotPCA(
  gobject = SpatialTrans_DMSO_ONTtrans,
  dim_reduction_name = "customPCA",  # Use the custom PCA
  save_plot = TRUE,                   # Save the plot
  save_param = base_save_parameters,  # Apply the save parameters
  default_save_name = "PCAplot_custom",  # Save plot with this name
  point_size = 4
)

# Display the custom PCA plot
print(PCAplot_custom)
```


# Step 10: Run t-SNE and UMAP
 ## 10a. Run t-UMAP
```{r}

# Run UMAP on the first 10 principal components
SpatialTrans_DMSO_ONTtrans <- runUMAP(
  gobject = SpatialTrans_DMSO_ONTtrans,
  dimensions_to_use = 1:4,          # Use the first 10 dimensions
  verbose = TRUE
)

# Visualize the UMAP plot
UMAPplot <- plotUMAP(
  gobject = SpatialTrans_DMSO_ONTtrans,
  save_plot = TRUE,                  # Save the plot
  save_param = base_save_parameters,   # Apply the save parameters
  default_save_name = "UMAPplot_PCA10",  # Save plot with this name
  point_size = 4
)

# Display the UMAP plot
print(UMAPplot)
```

 ## 10b. Run t-SNE

```{r}

# Run t-SNE on the first 10 principal components
SpatialTrans_DMSO_ONTtrans <- runtSNE(
  gobject = SpatialTrans_DMSO_ONTtrans,
  dimensions_to_use = 1:4,          # Use the first 10 dimensions
  verbose = TRUE
)

# Visualize the t-SNE plot
tSNEplot <- plotTSNE(
  gobject = SpatialTrans_DMSO_ONTtrans,
  save_plot = TRUE,                  # Save the plot
  save_param = base_save_parameters,   # Apply the save parameters
  default_save_name = "tSNEplot_PCA10",  # Save plot with this name
  point_size = 4
)

# Display the t-SNE plot
print(tSNEplot)
```

# 11 Clustering
```{r}
# Create a sNN network (default)
SpatialTrans_DMSO_ONTtrans <- createNearestNetwork(gobject = SpatialTrans_DMSO_ONTtrans, 
                                     dimensions_to_use = 1:4, 
                                     k = 30)
# Create a kNN network
SpatialTrans_DMSO_ONTtrans <- createNearestNetwork(gobject = SpatialTrans_DMSO_ONTtrans, 
                                     dimensions_to_use = 1:4, 
                                     k = 30,
                                     type = "kNN")

```


# Step 12: Leiden Clustering
 ## Plot in PCA Space
```{r}

# Step 12: Calculate Leiden clustering with a resolution of 0.4
SpatialTrans_DMSO_ONTtrans <- doLeidenCluster(
  gobject = SpatialTrans_DMSO_ONTtrans,
  resolution = 1.3,           # Resolution for clustering Try 1.0 if too many cluserts drop 
  n_iterations = 1000,        # Number of iterations
  nn_network_to_use = "sNN"   # Use the sNN or kNN network
)


# Visualize PCA plot colored by Leiden clusters
PCAplot_LeidenClusters <- plotPCA(
  gobject = SpatialTrans_DMSO_ONTtrans,
  cell_color = "leiden_clus",         # Color by Leiden clusters
  save_plot = TRUE,                   # Save the plot
  save_param = base_save_parameters,  # Apply the save parameters
  return_plot = TRUE, # Return the plot object to display after saving
  default_save_name = "plotPCA_LeidenClusters",  # Save plot with this name
  point_size = 4
)

# Display the PCA plot with Leiden clusters
print(PCAplot_LeidenClusters)

```


 ## Plot in UMAP Space
 ### Set the argument “show_NN_network = TRUE” to visualize the connections between spots.
```{r}
plotUMAP_LeidenClusters <- plotUMAP(gobject = SpatialTrans_DMSO_ONTtrans,
         cell_color = "leiden_clus", 
         show_NN_network = FALSE, 
         save_plot = TRUE,                   # Save the plot
         save_param = base_save_parameters,  # Apply the save parameters
         default_save_name = "plotUMAP_LeidenClusters",  # Save plot with this name
         point_size = 4)
      
print(plotUMAP_LeidenClusters)


plotUMAP_LeidenClusters_NN_network <- plotUMAP(gobject = SpatialTrans_DMSO_ONTtrans,
         cell_color = "leiden_clus", 
         show_NN_network = TRUE, 
         save_plot = TRUE,                   # Save the plot
         save_param = base_save_parameters,  # Apply the save parameters
         default_save_name = "plotUMAP_LeidenClusters_NN_network",  # Save plot with this name
         point_size = 4)
      
print(plotUMAP_LeidenClusters_NN_network )

```

## Plot in PCA Space
```{r}
plottSNE_LeidenClusters <- plotTSNE(gobject = SpatialTrans_DMSO_ONTtrans,
         cell_color = "leiden_clus", 
         show_NN_network = FALSE, 
         save_plot = TRUE,                   # Save the plot
         save_param = base_save_parameters,  # Apply the save parameters
         default_save_name = "plottSNE_LeidenClusters",  # Save plot with this name
         point_size = 4)
      
print(plottSNE_LeidenClusters)


plottSNE_LeidenClusters_NN_network <- plotTSNE(gobject = SpatialTrans_DMSO_ONTtrans,
         cell_color = "leiden_clus", 
         show_NN_network = TRUE, 
         save_plot = TRUE,                   # Save the plot
         save_param = base_save_parameters,  # Apply the save parameters
         default_save_name = "plottSNE_LeidenClusters_NN_network",  # Save plot with this name
         point_size = 4)
      
print(plottSNE_LeidenClusters_NN_network)
```

## Step 12b Using the cluster ID Spactially & Calculate Louvain clustering

```{r}

# Create a QC plot after filtering, using the same SpatialTrans_DMSO_ONTtrans object
SpatPlot2_Leiden_clusters <- spatPlot2D(
  gobject = SpatialTrans_DMSO_ONTtrans,  # Use the same object with statistics
  cell_color = "leiden_clus",           # Color based on the number of features (genes) per spot
  point_size = 5,
  point_alpha = 0.7,
  show_image = TRUE,                 # Show the underlying image
  save_plot = TRUE,                  # Save the plot
  save_param = base_save_parameters,   # Apply the save parameters
  return_plot = TRUE,                 # Return the plot object to display after saving
  default_save_name = "SpatPlot2_Leiden_clusters"  # Save plot with this name
)

# Display the QC plot after filtering
print(SpatPlot2_Leiden_clusters)
```


## Step 12c Calculate Louvain clustering
```{r}
SpatialTrans_DMSO_ONTtrans <- doLouvainCluster(SpatialTrans_DMSO_ONTtrans)

# Create a QC plot after filtering, using the same SpatialTrans_DMSO_ONTtrans object
SpatPlot2_Louvain_clusters <- spatPlot2D(
  gobject = SpatialTrans_DMSO_ONTtrans,  # Use the same object with statistics
  cell_color = "louvain_clus",           # Color based on the number of features (genes) per spot
  point_size = 5,
  point_alpha = 0.7,
  show_image = TRUE,                 # Show the underlying image
  save_plot = TRUE,                  # Save the plot
  save_param = base_save_parameters,   # Apply the save parameters
  return_plot = TRUE,                 # Return the plot object to display after saving
  default_save_name = "SpatPlot2_Louvain_clusters"  # Save plot with this name
)
# Display the QC plot after filtering
print(SpatPlot2_Louvain_clusters)

```

# Visium Spatial Transcriptomics Analysis WorkShop II

# Step 13: Disfferential Expression Analysis
## Fini Markers

```{r}
gini_markers <- findMarkers_one_vs_all(gobject = SpatialTrans_DMSO_ONTtrans,
                                       method = "gini",
                                       expression_values = "normalized",
                                       cluster_column = "leiden_clus",
                                       min_feats = 10)

topgenes_gini <- gini_markers[, head(.SD, 5), by = "cluster"]$feats

violinPlot_giniMarker <- violinPlot(SpatialTrans_DMSO_ONTtrans, 
           feats = unique(topgenes_gini), 
           cluster_column = "leiden_clus",
           strip_text = 25,
           axis_text_x_size = 30,
           axis_text_y_size = 15, 
           strip_position = "right",
           save_param = list(base_width = 15, base_height = 30),
           default_save_name = "violinPlot_giniMarker_ledien_clus"  # Save plot with this name
)

print(violinPlot_giniMarker)

```

## Heatmap
```{r}
giniMarker_heatmap <- plotMetaDataHeatmap(SpatialTrans_DMSO_ONTtrans, 
                      selected_feats = unique(topgenes_gini),
                      metadata_cols = "leiden_clus",
                      x_text_size = 10, y_text_size = 10,
                      save_param = base_save_parameters,    # Apply the save parameters
                      return_plot = TRUE,               # Return the plot object to display after saving
                      default_save_name = "giniMarker_heatmap"  # Save plot with this name
)
```

### Visualize the scaled expression spatial distribution of the top expressed genes across the sample.

```{r}  
Spatial_Dist_giniMarker <- dimFeatPlot2D(
  SpatialTrans_DMSO_ONTtrans, 
  expression_values = "scaled",
  feats = sort(unique(topgenes_gini)),
  cow_n_col = 5, 
  point_size = 4,
  save_param = modifyList(base_save_parameters, list(base_width = 15, base_height = 20)),    # Override base width and height
  return_plot = TRUE,               # Return the plot object to display after saving
  default_save_name = "Spatial_Dist_giniMarker"  # Save plot with this name
)

print(Spatial_Dist_giniMarker)
```

```{r}
#Spatial expression patterns of the top genes changed in the clusters

spatial_topgini_genes <- spatFeatPlot2D(SpatialTrans_DMSO_ONTtrans, 
               expression_values = "scaled",
               feats = topgenes_gini[1:10],
               show_image = TRUE, 
               cow_n_col = 5, 
               point_size = 2.5,
               point_alpha = 0.7,
               save_param = modifyList(base_save_parameters, list(base_width = 20, base_height = 10)),    # Override base width and height
               return_plot = TRUE,               # Return the plot object to display after saving
               default_save_name = "spatial_topgini_genes"  # Save plot with this name
               )
print(spatial_topgini_genes)
```


## Scran Markers
 The Scran method is preferred for robust differential expression analysis, especially when addressing technical variability or differences in sequencing depth across spatial locations.

Calculate the top marker genes per cluster using the scran method
```{r}
scran_markers <- findMarkers_one_vs_all(gobject = SpatialTrans_DMSO_ONTtrans,
                                       method = "scran",
                                       expression_values = "normalized",
                                       cluster_column = "leiden_clus")
                                       
topgenes_scran <- scran_markers[, head(.SD, 5), by = "cluster"]$feats
View(scran_markers )
```

```{r}
#Get gene symbol for transcript ID
# Load the biomaRt library
library(biomaRt)

# Connect to the Ensembl biomart server
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

# Query biomaRt for the gene symbols based on ENST IDs
result <- getBM(attributes = c('ensembl_transcript_id', 'hgnc_symbol'), 
                filters = 'ensembl_transcript_id', 
                values = topgenes_scran, 
                mart = ensembl)

# Display the result
print(result)

```

Save scran results with gene names


```{r}
# Load required libraries
library(data.table)
library(biomaRt)

# Calculate the top marker genes per cluster using the scran method
scran_markers <- findMarkers_one_vs_all(gobject = SpatialTrans_DMSO_ONTtrans,
                                        method = "scran",
                                        expression_values = "normalized",
                                        cluster_column = "leiden_clus")

# Extract the transcript IDs from the "feats" column
topgenes_scran <- scran_markers[, head(.SD, 5), by = "cluster"]$feats

# Connect to the Ensembl biomart server
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

# Query biomaRt for the gene symbols based on ENST IDs
result <- getBM(attributes = c('ensembl_transcript_id', 'hgnc_symbol'), 
                filters = 'ensembl_transcript_id', 
                values = scran_markers$feats,  # Extract all transcript IDs from the scran_markers
                mart = ensembl)

# Convert result to a data.table
result_dt <- as.data.table(result)

# Merge the hgnc_symbol with the scran_markers based on the transcript ID
scran_markers_with_symbols <- merge(
  scran_markers, 
  result_dt, 
  by.x = "feats", 
  by.y = "ensembl_transcript_id", 
  all.x = TRUE
)

# Save the result as a CSV file
output_path <- "./figures/paper_figures/supplementary/scran_markers_with_symbols.csv"

fwrite(scran_markers_with_symbols, file = output_path)

# View the updated data
View(scran_markers_with_symbols)

# Print completion message
cat("The updated scran_markers with hgnc_symbol has been saved to:", output_path, "\n")
```


### Visualize
Plot the normalized expression distribution of the top expressed genes.
```{r}
violinPlot_scranMarker <- violinPlot(SpatialTrans_DMSO_ONTtrans, 
           feats = unique(topgenes_scran), 
           cluster_column = "leiden_clus",
           strip_text = 25, 
           axis_text_x_size = 30,
           axis_text_y_size = 15, 
           strip_position = "right",
           save_param = modifyList(base_save_parameters, list(base_width = 15, base_height = 40)),    # Override base width and heig 
           default_save_name = "violinPlot_scranMarker"  # Save plot with this name
)
           
print(violinPlot_scranMarker)     

```

# Heatmap
```{r}
heatmap_scranMarkers <- plotMetaDataHeatmap(SpatialTrans_DMSO_ONTtrans, 
                    selected_feats = unique(topgenes_scran),
                    metadata_cols = "leiden_clus",
                    x_text_size = 10, y_text_size = 10,
                    save_param = modifyList(base_save_parameters, list(base_width = 15, base_height = 20)),    # Override base width and height
                    return_plot = TRUE,               # Return the plot object to display after saving
                    default_save_name = "heatmap_scranMarkers"  # Save plot with this name
                    )
print(heatmap_scranMarkers)          
```

### Visualize the scaled expression spatial distribution of the top expressed genes across the sample.

```{r}
Spatial_Dist_scranMarkers <- dimFeatPlot2D(SpatialTrans_DMSO_ONTtrans, 
              expression_values = "scaled",
              feats = sort(unique(topgenes_scran)),
              cow_n_col = 5, 
              point_size = 5,
              save_param = modifyList(base_save_parameters, list(base_width = 20, base_height = 20)),    # Override base width and height
              return_plot = TRUE,               # Return the plot object to display after saving
              default_save_name = "Spatial_Dist_scranMarkers"  # Save plot with this name
              )
print(Spatial_Dist_scranMarkers)
          
```

```{r}
#Spatial expression patterns of the top genes changed in the clusters

spatial_topscran_genes <- spatFeatPlot2D(SpatialTrans_DMSO_ONTtrans, 
               expression_values = "scaled",
               feats = topgenes_scran[1:10],
               show_image = TRUE, 
               cow_n_col = 5, 
               point_size = 2.5,
               point_alpha = 0.7,
               save_param = modifyList(base_save_parameters, list(base_width = 20, base_height = 10)),    # Override base width and height
               return_plot = TRUE,               # Return the plot object to display after saving
               default_save_name = "spatial_topscran_genes"  # Save plot with this name
               )
print(spatial_topscran_genes)
```

# Step 14 Enrichment & Deconvolution
Visium spatial transcriptomics does not provide single-cell resolution, making cell type annotation a harder problem. Giotto provides several ways to calculate enrichment of specific cell-type signature gene lists.


# Step 16 Spatial expression patterns
## Patial variable genes
Create a spatial network

```{r}
SpatialTrans_DMSO_ONTtrans <- createSpatialNetwork(gobject = SpatialTrans_DMSO_ONTtrans,
                                     method = "kNN", 
                                     k = 30,
                                     maximum_distance_knn = 550,
                                     name = "spatial_network")
```

### Sav network plot

```{r}
# Function to generate and save the plot with different show_image values
save_spatPlot2D_with_show_image <- function(show_image_value, save_name_suffix) {
  spatPlot2D(
    gobject = SpatialTrans_DMSO_ONTtrans,  
    show_network = TRUE,
    network_color = "blue",
    show_image = show_image_value, 
    spatial_network_name = "spatial_network",
    save_param = base_save_parameters,    # Apply the save parameters
    return_plot = TRUE,               # Return the plot object to display after saving
    default_save_name = paste0("Spatial_Network_k_10_knn_550_", save_name_suffix)  # Append suffix to save name
  )
}

# Generate and save plots
Spatial_Network_with_image <- save_spatPlot2D_with_show_image(TRUE, "with_image")
Spatial_Network_without_image <- save_spatPlot2D_with_show_image(FALSE, "without_image")

# Display the plots
print(Spatial_Network_with_image)
print(Spatial_Network_without_image)

```


## Rank binarization
Rank the genes on the spatial dataset depending on whether they exhibit a spatial pattern location or not.

This step may take a few minutes to run.

```{r}
ranktest <- binSpect(SpatialTrans_DMSO_ONTtrans, 
                     bin_method = "rank",
                     calc_hub = TRUE, 
                     hub_min_int = 5,
                     spatial_network_name = "spatial_network")
```

```{r}                
ranktestRes <-ranktest$feats[1:20]
result <- getBM(attributes = c('ensembl_transcript_id', 'hgnc_symbol'), 
                filters = 'ensembl_transcript_id', 
                values = ranktestRes, 
                mart = ensembl)

# Display the result
print(result)
```
## Visualize top results
Plot the scaled expression of genes with the highest probability of being spatial genes.
```{r}
spatial_prob_genes <- spatFeatPlot2D(SpatialTrans_DMSO_ONTtrans, 
               expression_values = "scaled",
               feats = ranktest$feats[1:8],
               show_image = TRUE, 
               cow_n_col = 4, 
               point_size = 2.5,
               point_alpha = 0.7,
               save_param = modifyList(base_save_parameters, list(base_width = 20, base_height = 10)),    # Override base width and height
               return_plot = TRUE,               # Return the plot object to display after saving
               default_save_name = "spatial_prob_1_86_genes"  # Save plot with this name
               )
print(spatial_prob_genes)
```

#  Spatial co-expression modules

### Cluster the top 500 spatial genes into 20 clusters
```{r}
ext_spatial_genes <- ranktest[1:500,]$feats
 # Use detectSpatialCorGenes function to calculate pairwise distances between genes.
spat_cor_netw_DT <- detectSpatialCorFeats(
    SpatialTrans_DMSO_ONTtrans,
    method = "network",
    spatial_network_name = "spatial_network",
    subset_feats = ext_spatial_genes)
```



## Visualize
### Plot the scaled expression of the 3 genes with most similar spatial patterns to RPL32.

```{r}
# Function to identify top correlated genes and save spatial correlation plot
generate_spatial_corr_plot <- function(gene, top_n = 4) {
  
  # Identify most similar spatially correlated genes for the input gene
  top_genes <- showSpatialCorFeats(spat_cor_netw_DT, 
                                   feats = gene, 
                                   show_top_feats = 20)
  
  # Generate the spatial correlation plot and save it
  plot <- spatFeatPlot2D(
    SpatialTrans_DMSO_ONTtrans, 
    expression_values = "scaled",
    feats = top_genes$variable[1:top_n],    # Use the top N correlated genes
    point_size = 4,
    point_alpha = 0.7,
    show_image = TRUE,                     # Show the underlying image
    save_param = base_save_parameters,      # Apply base save parameters
    return_plot = TRUE,                     # Return the plot object for display
    default_save_name = paste0("spatial_spatialCorr_", gene)  # Save with gene name
  )
  
  # Print the plot (optional)
  print(plot)
  
  return(plot)
}

# Example usage: Generate and save plot for the gene "MT-CO1"
spatial_spatialCorr_LCN2 <- generate_spatial_corr_plot("ENST00000406381")

```

Plot aany transcript
```{r}
# Function to generate spatial correlation plot for any given gene
generate_spatial_corr_plot <- function(gene) {
  
  # Generate the spatial feature plot for the input gene
  plot <- spatFeatPlot2D(
    SpatialTrans_DMSO_ONTtrans, 
    expression_values = "normalized",
    feats = gene,    # Directly use the input gene
    point_size = 6,
    show_image = TRUE,                     # Show the underlying image
    save_param = base_save_parameters,      # Apply base save parameters
    return_plot = TRUE,                     # Return the plot object for display
    default_save_name = paste0("spatial_spatialCorr_", gene)  # Save with gene name
  )
  
  # Print the plot (optional)
  print(plot)
  
  return(plot)
}

# Example usage: Generate and save plot for the gene "ENST00000320717"
gene_name <- "ENST00000406381"
assign(paste0("spatial_spatialCorr_", gene_name), generate_spatial_corr_plot(gene_name))

```

# Cluster spatial genes

```{r}
spat_cor_netw_DT <- clusterSpatialCorFeats(spat_cor_netw_DT, 
                                           name = "spat_netw_clus", 
                                           k = 20)
```                                           
## Visualize clusters
### Plot the correlation of the top 500 spatial genes with their assigned cluster.
```{r}
heatmSpatialCorFeats(SpatialTrans_DMSO_ONTtrans,
                     spatCorObject = spat_cor_netw_DT,
                     use_clus_name = "spat_netw_clus",
                     heatmap_legend_param = list(title = NULL))
```


### Rank spatial correlated clusters and show genes for selected clusters
```{r}
netw_ranks <- rankSpatialCorGroups(
  SpatialTrans_DMSO_ONTtrans,
  spatCorObject = spat_cor_netw_DT, 
  use_clus_name = "spat_netw_clus")

``` 
### Plot the correlation and number of spatial genes in each cluster.

```{r}
top_netw_spat_cluster <- showSpatialCorFeats(spat_cor_netw_DT, 
                                            use_clus_name = "spat_netw_clus",
                                            selected_clusters = 6, 
                                            show_top_feats = 1)
```

### Create the metagene enrichment score per co-expression cluster
```{r}
cluster_genes_DT <- showSpatialCorFeats(spat_cor_netw_DT, 
                                        use_clus_name = "spat_netw_clus", 
                                        show_top_feats = 1)

cluster_genes <- cluster_genes_DT$clus 
names(cluster_genes) <- cluster_genes_DT$feat_ID

SpatialTrans_DMSO_ONTtrans <- createMetafeats(SpatialTrans_DMSO_ONTtrans, 
                                feat_clusters = cluster_genes, 
                                name = "cluster_metagene")
```

### Plot the spatial distribution of the metagene enrichment scores of each spatial co-expression cluster.
```{r}
spatCellPlot(SpatialTrans_DMSO_ONTtrans,
             spat_enr_names = "cluster_metagene",
             cell_annotation_values = netw_ranks$clusters,
             point_size = 1, 
             cow_n_col = 5)
```

# Step 17: Spatially informed clusters


```{r}
coexpr_dt <- data.table::data.table(
  genes = names(spat_cor_netw_DT$cor_clusters$spat_netw_clus),
  cluster = spat_cor_netw_DT$cor_clusters$spat_netw_clus)

data.table::setorder(coexpr_dt, cluster)

top30_coexpr_dt <- coexpr_dt[, head(.SD, 30) , by = cluster]

spatial_genes <- top30_coexpr_dt$genes
print(spatial_genes)

```


## Re-calculate the clustering

```{r}
#Use the spatial genes to calculate again the principal components, umap, network and clustering
SpatialTrans_DMSO_ONTtrans <- runPCA(gobject = SpatialTrans_DMSO_ONTtrans,
                       feats_to_use = spatial_genes,
                       name = "custom_pca")

SpatialTrans_DMSO_ONTtrans <- runUMAP(SpatialTrans_DMSO_ONTtrans, 
                        dim_reduction_name = "custom_pca", 
                        dimensions_to_use = 1:3,
                        name = "custom_umap")

SpatialTrans_DMSO_ONTtrans <- createNearestNetwork(gobject = SpatialTrans_DMSO_ONTtrans,
                                     dim_reduction_name = "custom_pca",
                                     dimensions_to_use = 1:, 
                                     k = 30,
                                     name = "custom_NN")

SpatialTrans_DMSO_ONTtrans <- doLeidenCluster(gobject = SpatialTrans_DMSO_ONTtrans, 
                                network_name = "custom_NN",
                                resolution = 1, 
                                n_iterations = 1000,
                                name = "custom_leiden")
```

### Visualize
### Plot the spatial distribution of the Leiden clusters calculated based on the spatial gene

```{r}
spatPlot2D(SpatialTrans_DMSO_ONTtrans, 
           cell_color = "custom_leiden",
           point_size = 3)
```

```{r}
plotUMAP(gobject = SpatialTrans_DMSO_ONTtrans, 
         cell_color = "custom_leiden")


```

# Step 18: Spatial domains HMRF
## Hidden Markov Random Field (HMRF) models capture spatial dependencies and segment tissue regions based on shared and gene expression patterns.

### Do HMRF with different betas on top 30 genes per spatial co-expression module
This step may take several minutes to run.
```{r}
HMRF_spatial_genes <- doHMRF(gobject = SpatialTrans_DMSO_ONTtrans,
                            expression_values = "normilized",
                            spatial_genes = spatial_genes, 
                            k = 20,
                            spatial_network_name = "spatial_network",
                            betas = c(0, 10, 5),
                            output_folder = "./results/Giotto_DMSO_results/11_HMRF/")
```
Add the HMRF results to the giotto object
```{r}
SpatialTrans_DMSO_ONTtrans <- addHMRF(gobject = SpatialTrans_DMSO_ONTtrans, 
                        HMRFoutput = HMRF_spatial_genes,
                        k = 20, 
                        betas_to_add = c(0, 10, 20, 30, 40),
                        hmrf_name = "HMRF")
```
## Visualize
### Plot the spatial distribution of the HMRF domains.
```{r}
Spat_Plot_HMRF <-spatPlot2D(gobject = SpatialTrans_DMSO_ONTtrans, 
           cell_color = "HMRF_k20_b.40",    
           save_param = base_save_parameters,
           return_plot = TRUE,
           default_save_name = "Spat_Plot_HMRF")

print(Spat_Plot_HMRF)
```        



